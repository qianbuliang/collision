<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<script type="text/javascript" src="../js/move.js"></script>
<script type="text/javascript" src="../entity/player.js"></script>
<body>
	<canvas width="800" height="600" id="cvs" style="border: 1px #ccc solid"></canvas>
	<script type="text/javascript">

		//上个例子中我们计算了线段与线段的交点
		//这里例子我们来处理计算快速点状或者小物体与另一个物体之间的碰撞,比如子弹与物体之间碰撞
		//为什么要通过线段与线段之间的碰撞来解决呢,因为代码中的世界是非连续的,上一秒的位置没有碰撞,下一秒可能就进入物体内部或者穿出物体,通过边界检测无法满足需求,所以我们计算下一次移动的位置,与这次位置形成线段,通过线段与物体各个边界的碰撞来解决

		let canvas=document.querySelector('#cvs');
		let ctx=canvas.getContext('2d');
		//申明一个点	
		let player=new Player(100,100,30);
		let _player={x:player.x,y:player.y}
		let vetexs=[];
		let bullets=[];
		let range=300;
		let d=Math.PI/2
		/*for(let i=Math.PI/4;i<=Math.PI*2+Math.PI/4;i+=d){
			vetexs.push({x:300+Math.cos(i)*200,y:300+Math.sin(i)*200})
		}*/
		vetexs.push({x:300,y:200},{x:400,y:200},{x:500,y:400},{x:400,y:300},{x:350,y:300},{x:300,y:500},{x:200,y:300})
		//vetexs.push({x:300,y:400})
		//移动工具类
		let move=new Move(1)
		let hit=null;
		let mx=0;
		let my=0;
		window.addEventListener('mousemove',e=>{
			mx=e.clientX
			my=e.clientY;
		})
		window.addEventListener('mousedown',e=>{
			let bullet={x:player.x+Math.cos(player.angle)*40,y:player.y+Math.sin(player.angle)*40,life:200,speed:10,angle:player.angle}
			bullets.push(bullet)
		})
		update();

		//更新函数
		function update(){
			for(let i=0;i<5;i++)
			updatePlayer()
			updateBullets();
			render();
			requestAnimationFrame(update);
		}

		function updatePlayer(){
			move.update(_player);
			hit=null;
			let hp=false;
			let c=0;
			if(vetexs.length>1){
				for(let i=0;i<vetexs.length-1;i++){
						let temp=pointToLineDistance(vetexs[i],vetexs[i+1],_player);
						if(temp.distance<player.radius&&(!hit||temp.distance<hit.distance)){
							temp.angle=Math.atan2(vetexs[i+1].y-vetexs[i].y,vetexs[i+1].x-vetexs[i].x)
							hit=temp;
							c++;
						}else if(hit&&hit.distance==temp.distance){
							if(hit.x==temp.x&&hit.y==temp.y){
								hp=true;
								c++;
							}
							break;
						}
					}
				
			if(!hp&&c<=1){
				for(let i=0;i<vetexs.length;i++){
					if(getDistance2(vetexs[i],_player)<player.radius*player.radius){
						hit=vetexs[i]
						hp=true;
						break;
					}
				}
				}
			}
			if(!hit){
				player.x=_player.x;
				player.y=_player.y;
			}else{
				let py={x:player.x,y:player.y}
				if(!hp){
					let angle=hit.angle
					move.update(py,angle,move.speed*Math.cos(angle-move.angle));
					hit=null
					for(let i=0;i<vetexs.length-1;i++){
					let temp=pointToLineDistance(vetexs[i],vetexs[i+1],py);
					if(temp.distance<player.radius&&(!hit||temp.distance<hit.distance)){
						temp.angle=Math.atan2(vetexs[i+1].y-vetexs[i].y,vetexs[i+1].x-vetexs[i].x)
						hit=temp;
					}
					}
					if(!hit){
						player.x=py.x;
						player.y=py.y;
					}
				}else{
					let angle=Math.atan2(py.y-hit.y,py.x-hit.x)-Math.PI/2
					move.update(py,angle,move.speed*Math.cos(angle-move.angle));
					hit=null;
					for(let i=0;i<vetexs.length-1;i++){
					let temp=pointToLineDistance(vetexs[i],vetexs[i+1],py);
					if(temp.distance<player.radius&&(!hit||temp.distance<hit.distance)){
						temp.angle=Math.atan2(vetexs[i+1].y-vetexs[i].y,vetexs[i+1].x-vetexs[i].x)
						hit=temp;
					}
					}
					if(!hit){
						player.x=py.x;
						player.y=py.y;
					}
				}
			}
			_player.x=player.x
			_player.y=player.y
			player.angle=Math.atan2(my-player.y,mx-player.x);
		}
		function getDistance2(p1,p2){
			return (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)
		}

		function drawDir(angle){
			ctx.beginPath();
			ctx.moveTo(player.x,player.y);
			ctx.lineTo(player.x+Math.cos(angle)*50,player.y+Math.sin(angle)*50);
			ctx.closePath();
			ctx.stroke();
		}
		//计算并更新子弹位置
		function updateBullets(){
			for(let i=bullets.length-1;i>=0;i--){
				let bullet=bullets[i]
				if(bullet.life<=0){
					bullets.splice(i,1)
					continue;
				}
				let bx=bullet.x+Math.cos(bullet.angle)*bullet.speed
				let by=bullet.y+Math.sin(bullet.angle)*bullet.speed
				let bt={x:bx,y:by}
				let collision=null
				for(let i=0;i<vetexs.length-1;i++){
					let temp=getIntersection(vetexs[i],vetexs[i+1],bullet,bt)
					if(temp&&(!collision||temp.rate<collision.rate)){
						collision=temp;
						collision.v={x:vetexs[i+1].x-vetexs[i].x,y:vetexs[i+1].y-vetexs[i].y}
					}
				}
				if(collision){
					let angle=2*Math.atan2(collision.v.y,collision.v.x)-bullet.angle
					bullet.x=collision.x;
					bullet.y=collision.y;
					bullet.angle=angle;
					bullet.x+=Math.cos(bullet.angle)*0.01
					bullet.y+=Math.sin(bullet.angle)*0.01
				}else{
					bullet.x=bx;
					bullet.y=by;
				}
				bullet.life--;
			}
		}

		
		//渲染函数
		function render(){
			ctx.clearRect(0,0,800,600);
			drawPlayer()
			drawLine()
			drawBullets()
		}
		//画玩家
		function drawPlayer(){
			player.render(ctx)
		}
		//画线
		function drawLine(){
			ctx.beginPath();
			for(let i=0;i<vetexs.length-1;i++){
				ctx.moveTo(vetexs[i].x,vetexs[i].y);
				ctx.lineTo(vetexs[i+1].x,vetexs[i+1].y);
			}
			ctx.closePath();
			ctx.stroke();
		}
		//画子弹
		function drawBullets(){
			ctx.fillStyle="#000"
			bullets.forEach(b=>{
				ctx.beginPath()
				ctx.arc(b.x,b.y,2,0,Math.PI*2)
				ctx.closePath()
				ctx.fill();
			})
		}
		

		//交点算法,通过列方程组化简
		//假设p1-p2线段与p3-p4线段有交点
		//交点位于p1->p2线段占比为n,(这个占比=(p1->交点)/(p1->p2))
		//交点位于p3->p4线段占比为m,(这个占比=(p3->交点)/(p3->p4))
		//那么可以得出 交点x位置为x1+Δx1*n,还等于x3+Δx3*m
		//同理得出交点y位置为y1+Δy1*n,还等于y3+Δy3*m
		//列方程组并化简可以得出m=(y1+(Δy1/Δx1)*(x3-x1)-y3)/(Δy3-(Δy1/Δx1)*Δx3)
		//n=(x3+Δx3*m-x1)/(Δx1)
		function getIntersection(p1,p2,p3,p4) {
			let dx1=p2.x-p1.x;  //Δx1
			let dy1=p2.y-p1.y;  //Δy1
			let dx3=p4.x-p3.x;  //Δx3
			let dy3=p4.y-p3.y;  //Δy3
			let k1=(dy1/dx1);   
			let k3=(dy3/dx3);
			if(k1==k3||k1==-k3)return null; //斜率相等或者相反,代表平行,平行无交点
			let m=(p1.y+k1*(p3.x-p1.x)-p3.y)/(dy3-(k1)*dx3)
			if (isNaN(m)) return null;
			let n=(p3.x+dx3*m-p1.x)/(dx1)
			//console.log(m,n)
			if(m<0||m>1||n<0||n>1){
				return null;
			}
			return {
				x:p3.x+dx3*m, //碰撞点的x坐标
				y:p3.y+dy3*m, //碰撞点的y坐标
				rate:m        //在线段3-4的占比
			}
		}



		//点到线段距离
		//p1,p2线段
		//p3为点
		//点到直线的最近距离是垂线,但是如果点到线段的距离不一样
		//在点与线段起始点组成的角度都是锐角时,点向线段的垂线在线段内,为最近
		//在点与线段起始点任意一个组成的角度是顿角时,点向线段的垂线在线段外,点到线段最近距离为组成钝角的那个起点或者终点
		//如何判断两个向量的夹角时什么角呢,向量a·向量b=|a|*|b|*cos(θ)=x1*x2+y1*y2
		//所以cos(θ)=(x1*x2+y1*y2)/(|a|*|b|)
		//因为只需要判断钝角还是锐角,|a|和|b|均为正
		//所以(x1*x2+y1*y2)>0时为锐角,(x1*x2+y1*y2)<0时为钝角
		//所以距离分三种情况
		//命名方便理解 如:v12代表线段1-2,方向1指向2
		//为了详细展示效果,返回值中我添加了最近距离的点的计算,按实际需求决定是否计算
		function pointToLineDistance(p1,p2,p3){

			let v12={x:p2.x-p1.x,y:p2.y-p1.y};
			let v13={x:p3.x-p1.x,y:p3.y-p1.y};
			if(dc(v12,v13)<0)return {x:p1.x,y:p1.y,distance:mc(v13)};

			let v21={x:-v12.x,y:-v12.y};
			let v23={x:p3.x-p2.x,y:p3.y-p2.y}
			if(dc(v21,v23)<0)return {x:p2.x,y:p2.y,distance:mc(v23)};

			//12线段角度
			let angle_12=jd(v12);
			//13线段角度
			let angle_13=jd(v13);
			//12和13夹角
			let angle=angle_13-angle_12;
			//垂线角度
			let d_angle=angle_12-Math.PI/2
			//13模长
			let m13=mc(v13)
			//这个distance可能为正可能为负
			let distance=m13*Math.sin(angle)
			let x=p3.x+Math.cos(d_angle)*distance
			let y=p3.y+Math.sin(d_angle)*distance
			return {x:x,y:y,distance:Math.abs(distance)};

		}

		//向量点乘
		function dc(v1,v2){
			return v1.x*v2.x+v1.y*v2.y;
		}
		//向量模长
		function mc(v){
			return Math.sqrt(v.y*v.y+v.x*v.x);
		}
		//向量角度
		function jd(v){
			return Math.atan2(v.y,v.x);
		}
	</script>
</body>
</html>